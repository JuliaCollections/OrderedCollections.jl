var documenterSearchIndex = {"docs":
[{"location":"#OrderedCollections.jl","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"","category":"section"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"This package implements associative containers that preserve the order of insertion:","category":"page"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"OrderedDict\nOrderedSet\nLittleDict","category":"page"},{"location":"#OrderedSets","page":"OrderedCollections.jl","title":"OrderedSets","text":"","category":"section"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"OrderedSets are sets whose entries have a particular order. Order refers to insertion order, which allows deterministic iteration over the set:","category":"page"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"using Base.MathConstants\ns = OrderedSet((π,e,γ,catalan,φ))\nfor x in s\n   println(x)\nend\n#> π = 3.1415926535897...\n#> ℯ = 2.7182818284590...\n#> γ = 0.5772156649015...\n#> catalan = 0.9159655941772...\n#> φ = 1.6180339887498...","category":"page"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"All Set operations are available for OrderedSets.","category":"page"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"Note that to create an OrderedSet of a particular type, you must specify the type in curly-braces:","category":"page"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"# create an OrderedSet of Strings\nstrs = OrderedSet{AbstractString}()","category":"page"},{"location":"#OrderedDicts","page":"OrderedCollections.jl","title":"OrderedDicts","text":"","category":"section"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"Similarly, OrderedDict are simply dictionaries whose entries have a particular order.","category":"page"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"d = OrderedDict{Char,Int}()\nfor c in 'a':'d'\n    d[c] = c-'a'+1\nend\nfor x in d\n   println(x)\nend\n#> 'a' => 1\n#> 'b' => 2\n#> 'c' => 3\n#> 'd' => 4","category":"page"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"The insertion order is conserved when iterating on the dictionary itself, its keys (through keys(d)), or its values (through values(d)). All standard Associative and Dict functions are available for OrderedDicts","category":"page"},{"location":"#LittleDict","page":"OrderedCollections.jl","title":"LittleDict","text":"","category":"section"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"d = LittleDict{Char,Int}()\nfor c in 'a':'d'\n    d[c] = c-'a'+1\nend\nfor x in d\n   println(x)\nend\n#> 'a' => 1\n#> 'b' => 2\n#> 'c' => 3\n#> 'd' => 4","category":"page"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"The LittleDict acts similarly to the OrderedDict. However for small collections it is much faster. Indeed the preceeding example (with the io redirected to devnull), runs 4x faster in the LittleDict version as the earlier OrderedDict version.","category":"page"},{"location":"","page":"OrderedCollections.jl","title":"OrderedCollections.jl","text":"OrderedDict\nOrderedSet\nLittleDict\nLittleSet\nfreeze\nOrderedCollections.isordered","category":"page"},{"location":"#OrderedCollections.OrderedDict","page":"OrderedCollections.jl","title":"OrderedCollections.OrderedDict","text":"OrderedDict\n\nOrderedDicts are simply dictionaries whose entries have a particular order. The order refers to insertion order, which allows deterministic iteration over the dictionary.\n\n\n\n\n\n","category":"type"},{"location":"#OrderedCollections.OrderedSet","page":"OrderedCollections.jl","title":"OrderedCollections.OrderedSet","text":"OrderedSet\n\nOrderedSets are simply sets whose entries have a particular order. The order refers to insertion order, which allows deterministic iteration over the set.\n\nNote: To create an OrderedSet of a particular type, you must specify the type, such as,\n\nos = OrderedSet{Int}(3)\npush!(os, [1,2]...)\n\n\n\n\n\n","category":"type"},{"location":"#OrderedCollections.LittleDict","page":"OrderedCollections.jl","title":"OrderedCollections.LittleDict","text":"LittleDict(keys, vals) <: AbstractDict\n\nAn ordered dictionary type for small numbers of keys. Rather than using hash or some other sophisticated measure to store the vals in a clever arrangement, it just keeps everything in a pair of lists.\n\nWhile theoretically this has expected time complexity O(n) (vs the hash-based OrderedDict/Dict's expected time complexity O(1), and the search-tree-based SortedDict's expected time complexity O(log(n))), in practice it is really fast, because it is cache & SIMD friendly.\n\nIt is reasonable to expect it to outperform an OrderedDict, with up to around 30 elements in general; or with up to around 50 elements if using a LittleDict backed by Tuples (see freeze) However, this depends on exactly how long isequal and hash take, as well as on how many hash collisions occur etc.\n\nnote: Note\nWhen constructing a LittleDict it is faster to pass in the keys and values each as seperate lists. So if you have them seperately already, do LittleDict(ks, vs) not LittleDict(zip(ks, vs)). Furthermore, key and value lists that are passed as Tuples will not require any copies to create the LittleDict, so LittleDict(ks::Tuple, vs::Tuple) is the fastest constructor of all.\n\n\n\n\n\n","category":"type"},{"location":"#OrderedCollections.LittleSet","page":"OrderedCollections.jl","title":"OrderedCollections.LittleSet","text":"LittleSet([itr]) <: AbstractSet\n\nConstructs an ordered set optimized for a small number of elements, given the iterable itr. The underlying data is stored as either an AbstractVector or a Tuple and is optimal for 30-50 elements, similar to LittleDict.\n\n\n\n\n\n","category":"type"},{"location":"#OrderedCollections.freeze","page":"OrderedCollections.jl","title":"OrderedCollections.freeze","text":"freeze(dd::AbstractDict)\n\nRender a dictionary immutable by converting it to a Tuple-backed LittleDict. The Tuple-backed LittleDict is faster than the Vector-backed LittleDict, particularly when the keys are all concretely typed.\n\n\n\n\n\n","category":"function"},{"location":"#OrderedCollections.isordered","page":"OrderedCollections.jl","title":"OrderedCollections.isordered","text":"isordered(::Type)\n\nProperty of associative containers, that is true if the container type has a defined order (such as OrderedDict and SortedDict), and false otherwise.\n\n\n\n\n\n","category":"function"}]
}
